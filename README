Basic class and operations for dealing with timing variables. 

For example, given measurements in seconds, the timing class will allow
for easy conversion to hh:mm:ss. This is useful for converting fractional
measurements into a neater format. For example,

> library(timing)
> x <- 1.5
> print(convert(x,units="hrs"))
[1] "1:30:00"

It also allows for arithmetic operations to be handled in an intuitive way:

> y <- convert(seq(0,10,by=0.25),units="hrs")
> print(mean(y))
[1] "5:00:00"
> print(quantile(y,prob=c(0.0,0.25,0.5,0.75,1.0)))
[1] "0:00:00"  "2:30:00"  "5:00:00"  "7:30:00"  "10:00:00"
> print(range(y))
[1] "0:00:00"  "10:00:00"
> print(sum(y[1:3]))
Error in sum(y[1:3]) : invalid 'type' (list) of argument
> print(sum(y))
[1] "205:00:00"

TODO:

-- Allow for indexing e.g., y[1] doesn't work...
-- Allow for printing to screen


From devtools:

Best practices
Create a construction method that checks the types of the input, and returns a list with the correct class label. XXX <- function(...) {}

Write a function to check if an object is of your class: is.XXX <- function(x) inherits(x, "XXX")

When implementing a vector class, you should implement these methods: length, [, [<-, [[, [[<-, c. (If [ is implemented rev, head, and tail should all work).

When implementing anything mathematical, implement Ops, Math and Summary.

When implementing a matrix/array class, you should implement these methods: dim (gets you nrow and ncol), t, dimnames (gets you rownames and colnames), dimnames<- (gets you colnames<-, rownames<-), cbind, rbind.

If you're implementing more complicated print() methods, it's a better idea to implement format() methods that return a string, and then implement print.class <- function(x, ...) cat(format(x, ...), "\n". This makes for methods that are much easier to compose, because the side-effects are isolated to a single place.
